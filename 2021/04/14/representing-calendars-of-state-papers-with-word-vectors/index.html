<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.82.0" />


<title>Representing Calendars of State Papers with Word Vectors - Networking Archives Blog</title>
<meta property="og:title" content="Representing Calendars of State Papers with Word Vectors - Networking Archives Blog">


  <link href='https://networkingarchives.github.io/blog/favicon.ico' rel='icon' type='image/x-icon'/>



  








<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="/blog/css/fonts.css" media="all">
<link rel="stylesheet" href="/blog/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/blog/" class="nav-logo">
    <img src="/blog/images/logo.png"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/blog/about/">About</a></li>
    
    <li><a href="https://github.com/rstudio/blogdown">GitHub</a></li>
    
    <li><a href="https://twitter.com/rstudio">Twitter</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">26 min read</span>
    

    <h1 class="article-title">Representing Calendars of State Papers with Word Vectors</h1>

    
    <span class="article-date">2021-04-14</span>
    

    <div class="article-content">
      
<script src="https://networkingarchives.github.io/blog/2021/04/14/representing-calendars-of-state-papers-with-word-vectors/index_files/header-attrs/header-attrs.js"></script>
<script src="https://networkingarchives.github.io/blog/2021/04/14/representing-calendars-of-state-papers-with-word-vectors/index_files/htmlwidgets/htmlwidgets.js"></script>
<script src="https://networkingarchives.github.io/blog/2021/04/14/representing-calendars-of-state-papers-with-word-vectors/index_files/plotly-binding/plotly.js"></script>
<script src="https://networkingarchives.github.io/blog/2021/04/14/representing-calendars-of-state-papers-with-word-vectors/index_files/typedarray/typedarray.min.js"></script>
<script src="https://networkingarchives.github.io/blog/2021/04/14/representing-calendars-of-state-papers-with-word-vectors/index_files/jquery/jquery.min.js"></script>
<link href="https://networkingarchives.github.io/blog/2021/04/14/representing-calendars-of-state-papers-with-word-vectors/index_files/crosstalk/css/crosstalk.css" rel="stylesheet" />
<script src="https://networkingarchives.github.io/blog/2021/04/14/representing-calendars-of-state-papers-with-word-vectors/index_files/crosstalk/js/crosstalk.min.js"></script>
<link href="https://networkingarchives.github.io/blog/2021/04/14/representing-calendars-of-state-papers-with-word-vectors/index_files/plotly-htmlwidgets-css/plotly-htmlwidgets.css" rel="stylesheet" />
<script src="https://networkingarchives.github.io/blog/2021/04/14/representing-calendars-of-state-papers-with-word-vectors/index_files/plotly-main/plotly-latest.min.js"></script>


<div id="text-and-models" class="section level3">
<h3>Text and Models</h3>
<p>Many Digital Humanities projects <a href="https://doi.org/10.1093/llc/fqw045">involve</a> constructing <em>models</em> of text: a general name for a kind of representation of text which makes it in some way easier to interpret. TEI-encoded text is an example of a model: we take the ‘raw material’ of a document, its text, and add elements to it to make it easier to work with and analyse. Models are often further abstracted from the original text. One way we can represent text in a way that a machine can interpret is with a <em>word vector.</em> A word vector is simply a numerical representation of a word within a corpus (a body of text, often a series of documents), usually consisting of a series of numbers in a specified sequence. This type of representation is used for a variety of Natural Language Processing tasks - for instance measuring the similarity between two documents.</p>
<p>This post uses a couple of R packages and a method for creating word vectors with a neural net, called <a href="https://nlp.stanford.edu/projects/glove/">GloVe</a>, to produce a series of vectors which give useful clues as to the semantic links between words in a corpus. The method is then used to analyse the printed summaries of the English State Papers, from <a href="https://www.gale.com/primary-sources/state-papers-online">State Papers Online</a>, and show how they can be used to understand how the association between words and concepts changed over the course of the seventeenth century.</p>
</div>
<div id="what-is-a-word-vector-then" class="section level3">
<h3>What is a Word Vector, Then?</h3>
<p>First, I’ll try to briefly explain word vectors. Imagine you have two documents in a corpus. One of them is an article about pets, and the other is a piece of fiction about a team of crime fighting animal superheroes. We’ll call them document A and document B. One way to represent the words within these documents as a vector would be to use the counts of each word per document.</p>
<p>To do this, you could give each word a set of coordinates, <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, where <span class="math inline">\(x\)</span> is a count of how many times the word appears in document A and <span class="math inline">\(y\)</span> the number of times it appears in document B.</p>
<p>The first step is to make a dataframe with the relevant counts:</p>
<pre class="r"><code>library(ggrepel)
library(tidyverse)
word_vectors = tibble(word = c(&#39;crufts&#39;, &#39;feed&#39;, &#39;cat&#39;, &#39;dog&#39;, &#39;mouse&#39;, &#39;rabbit&#39;, &#39;cape&#39;, &#39;hero&#39; ),
      x = c(10, 8, 6, 5, 6, 5, 2, 1),
      y = c(0, 1, 3, 5, 8, 8, 10, 9))

word_vectors</code></pre>
<pre><code>## # A tibble: 8 x 3
##   word       x     y
##   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;
## 1 crufts    10     0
## 2 feed       8     1
## 3 cat        6     3
## 4 dog        5     5
## 5 mouse      6     8
## 6 rabbit     5     8
## 7 cape       2    10
## 8 hero       1     9</code></pre>
<p>This data can be represented as a two-dimensional plot where each word is placed on the x and y axes based on their x and y values, like this:</p>
<pre class="r"><code>ggplot() + 
  geom_point(data = word_vectors, aes(x, y), size =4, alpha = .7) + 
  geom_text_repel(data = word_vectors, aes(x, y, label = word)) + 
  theme_bw() + 
  labs(title = &quot;Words Represented in Two-dimension Space&quot;) + 
  theme(title = element_text(face = &#39;bold&#39;)) + 
  scale_x_continuous(breaks = 1:10) + 
  scale_y_continuous(breaks = 1:10)</code></pre>
<p><img src="https://networkingarchives.github.io/blog/2021/04/14/representing-calendars-of-state-papers-with-word-vectors/index_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>Each word is represented as a <em>vector</em> of length 2: ‘rabbit’ is a vector containing two numbers: {5,8}, for example. Using very basic maths we can calculate the <em>euclidean</em> <em>distance</em> between any pair of words. More or less the only thing I can remember from secondary school math is how to calculate the distance between two points on a graph, using the following formula:</p>
<p><span class="math display">\[
\sqrt {\left( {x_1 - x_2 } \right)^2 + \left( {y_1 - y_2 } \right)^2 }
\]</span></p>
<p>Where <span class="math inline">\(x\)</span> is the first point and <span class="math inline">\(y\)</span> the second. This can easily be turned into a function in R, which takes a set of coordinates (the arguments x1 and x2) and returns the euclidean distance:</p>
<pre class="r"><code>euc.dist &lt;- function(x1, x2) sqrt(sum((pointA - pointB) ^ 2))</code></pre>
<p>To get the distance between ‘crufts’ and ‘mouse’, set pointA as the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> ccoordinates for the first entry in the dataframe of coordinates we created above, and pointB the coordinates for the fifth entry:</p>
<pre class="r"><code>pointA = c(word_vectors$x[1], word_vectors$y[1])
pointB = c(word_vectors$x[5], word_vectors$y[5])

euc.dist(pointA, pointB)</code></pre>
<pre><code>## [1] 8.944272</code></pre>
<p>Representing a pair of words as vectors and measuring the distance between them is commonly used to suggest a semantic link between the two. For instance, the distance between ‘hero’ and ‘cape’ in this corpus is small, because they have similar properties: they both occur mostly in the document about superheroes and rarely in the document about pets.</p>
<pre class="r"><code>pointA = c(word_vectors$x[word_vectors$word == &#39;hero&#39;], word_vectors$y[word_vectors$word == &#39;hero&#39;])

pointB = c(word_vectors$x[word_vectors$word == &#39;cape&#39;], word_vectors$y[word_vectors$word == &#39;cape&#39;])

euc.dist(pointA, pointB)</code></pre>
<pre><code>## [1] 1.414214</code></pre>
<p>This suggests that the model has ‘learned’ that in this corpus, hero and cape are semantically more closely linked than other pairs in the dataset. The difference between ‘cape’ and ‘feed’, on the other hand, is large, because one appears often in the superheroes article and rarely in the other, and vice versa.</p>
<pre class="r"><code>pointA = c(word_vectors$x[word_vectors$word == &#39;cape&#39;], word_vectors$y[word_vectors$word == &#39;cape&#39;])

pointB = c(word_vectors$x[word_vectors$word == &#39;feed&#39;], word_vectors$y[word_vectors$word == &#39;feed&#39;])

euc.dist(pointA, pointB)</code></pre>
<pre><code>## [1] 10.81665</code></pre>
</div>
<div id="multi-dimensional-vectors" class="section level3">
<h3>Multi-Dimensional Vectors</h3>
<p>These vectors, each consisting of two numbers, can be thought of as two-dimensional vectors: a type which can be represented on a 2D scatterplot as <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>. It’s very easy to add a third dimension, <span class="math inline">\(z\)</span>:</p>
<pre class="r"><code>word_vectors_3d = tibble(word = c(&#39;crufts&#39;, &#39;feed&#39;, &#39;cat&#39;, &#39;dog&#39;, &#39;mouse&#39;, &#39;rabbit&#39;, &#39;cape&#39;, &#39;hero&#39; ),
      x = c(10, 8, 6, 5, 6, 5, 2, 1),
      y = c(0, 1, 3, 5, 8, 8, 10, 9),
      z = c(1,3,5,2,7,8,4,3))</code></pre>
<p>Just like the plot above, we can plot the words in three dimensions, using <a href="https://plotly.com/r/">Plotly</a>:</p>
<pre class="r"><code>library(plotly)

plot_ly(data = word_vectors_3d, x =  ~x, y = ~y,z =  ~z, text = ~word) %&gt;% add_markers() %&gt;% layout(title = &quot;3D Representation of Word Vectors&quot;)</code></pre>
<div id="htmlwidget-1" style="width:672px;height:480px;" class="plotly html-widget"></div>
<script type="application/json" data-for="htmlwidget-1">{"x":{"visdat":{"316d4b74dfba":["function () ","plotlyVisDat"]},"cur_data":"316d4b74dfba","attrs":{"316d4b74dfba":{"x":{},"y":{},"z":{},"text":{},"alpha_stroke":1,"sizes":[10,100],"spans":[1,20],"type":"scatter3d","mode":"markers","inherit":true}},"layout":{"margin":{"b":40,"l":60,"t":25,"r":10},"title":"3D Representation of Word Vectors","scene":{"xaxis":{"title":"x"},"yaxis":{"title":"y"},"zaxis":{"title":"z"}},"hovermode":"closest","showlegend":false},"source":"A","config":{"showSendToCloud":false},"data":[{"x":[10,8,6,5,6,5,2,1],"y":[0,1,3,5,8,8,10,9],"z":[1,3,5,2,7,8,4,3],"text":["crufts","feed","cat","dog","mouse","rabbit","cape","hero"],"type":"scatter3d","mode":"markers","marker":{"color":"rgba(31,119,180,1)","line":{"color":"rgba(31,119,180,1)"}},"error_y":{"color":"rgba(31,119,180,1)"},"error_x":{"color":"rgba(31,119,180,1)"},"line":{"color":"rgba(31,119,180,1)"},"frame":null}],"highlight":{"on":"plotly_click","persistent":false,"dynamic":false,"selectize":false,"opacityDim":0.2,"selected":{"opacity":1},"debounce":0},"shinyEvents":["plotly_hover","plotly_click","plotly_selected","plotly_relayout","plotly_brushed","plotly_brushing","plotly_clickannotation","plotly_doubleclick","plotly_deselect","plotly_afterplot","plotly_sunburstclick"],"base_url":"https://plot.ly"},"evals":[],"jsHooks":[]}</script>
<p>You can start to understand how the words now cluster together in the 3D plot: rabbit and mouse are clustered together, but now in the third dimension they are further away from dog. We can use the same formula as above to calculate these distances, just by adding the z coordinates to the pointA and pointB vectors:</p>
<pre class="r"><code>pointA = c(word_vectors$x[word_vectors$word == &#39;dog&#39;], word_vectors$y[word_vectors$word == &#39;dog&#39;], word_vectors$z[word_vectors$word == &#39;dog&#39;])</code></pre>
<pre><code>## Warning: Unknown or uninitialised column: `z`.</code></pre>
<pre class="r"><code>pointB = c(word_vectors$x[word_vectors$word == &#39;mouse&#39;], word_vectors$y[word_vectors$word == &#39;mouse&#39;], word_vectors$z[word_vectors$word == &#39;mouse&#39;])</code></pre>
<pre><code>## Warning: Unknown or uninitialised column: `z`.</code></pre>
<pre class="r"><code>euc.dist(pointA, pointB)</code></pre>
<pre><code>## [1] 3.162278</code></pre>
<p>The nice thing about the method is that while my brain starts to hurt when I think about more than three dimensions, the maths behind it doesn’t care: you can just keep plugging in longer and longer vectors and it’ll continue to calculate the distances as long as they are the same length. This means you can use this same formula not just when you have x and y coordinates, but also z, a, b, c, d, and so on for as long as you like. This is often called ‘representing words in multi-dimensional euclidean space’, or something similar which sounds great on grant applications but it’s really just doing some plotting and measuring distances. Which means that if you represent all the words in a corpus as a long vector (series of coordinates), you can quickly measure the distance between any two.</p>
<p>In a large corpus with a properly-constructed vector representation, the semantic relationships between the words start to make a lot of sense. What’s more, because of vector math, you can add, subtract, divide and multiply the words together to get new vectors, and then find the closest to that. Here, we create a new vector, which is pointA - pointB (dog - mouse). Then loop through each vector and calculate the distance, and display in a new dataframe:</p>
<pre class="r"><code>pointC = pointA - pointB

df_for_results = tibble()
for(i in 1:8){
  
  pointA = c(word_vectors$x[i], word_vectors$y[i], word_vectors$z[i])
  u = tibble(dist = euc.dist(pointC, pointA), word = word_vectors$word[i])
  df_for_results = rbind(df_for_results, u)
}</code></pre>
<pre><code>## Warning: Unknown or uninitialised column: `z`.

## Warning: Unknown or uninitialised column: `z`.

## Warning: Unknown or uninitialised column: `z`.

## Warning: Unknown or uninitialised column: `z`.

## Warning: Unknown or uninitialised column: `z`.

## Warning: Unknown or uninitialised column: `z`.

## Warning: Unknown or uninitialised column: `z`.

## Warning: Unknown or uninitialised column: `z`.</code></pre>
<pre class="r"><code>df_for_results %&gt;% arrange(dist)</code></pre>
<pre><code>## # A tibble: 8 x 2
##    dist word  
##   &lt;dbl&gt; &lt;chr&gt; 
## 1  0    mouse 
## 2  1    rabbit
## 3  3.16 dog   
## 4  4.47 cape  
## 5  5    cat   
## 6  5.10 hero  
## 7  7.28 feed  
## 8  8.94 crufts</code></pre>
<p>The closest to dog - mouse is hero, with this vector representation.</p>
<div id="from-vectors-to-word-embeddings" class="section level4">
<h4>From Vectors to Word Embeddings</h4>
<p>These vectors are also known as word embeddings. Real algorithms base the vectors on more sophisticated metrics than that I used above. Some, such as <a href="https://nlp.stanford.edu/projects/glove/">GloVe</a> record co-occurrence probabilities (the likelihood of every pair of words in a corpus to co-occur within a set ‘window’ of words either side), using a neural network, and pre-trained over enormous corpora of text. The resulting vectors are often used to represent the relationships between modern meanings of words, to <a href="https://dh2017.adho.org/abstracts/582/582.pdf">track semantic changes over time</a>, or to understand the history of <a href="https://ccdkconceptlab.wordpress.com/">concepts</a>, though it’s worth pointing out they’re only as representative as the corpus used (many use sources such as Wikipedia, or Reddit, mostly produced by white men and so there’s a danger of biases towards those groups).</p>
<p>Word embeddings are often critiqued as reflecting or propogating bias (I highly recommend Kaspar Beelen’s post and tools to understand more about this) of their source texts. The source used here is a corpus consisting of the printed summaries of the Calendars of State Papers, which I’ve described in detail <a href="https://networkingarchives.github.io/blog/2021/04/14/text-mining/">here</a>. As such it is likely highly biased, but if the purpose of an analysis is historical, for example to understand how a concept was represented at a given time, by a specific group, in a particular body of text, the biases captured by word embeddings can be seen as a research strength rather than a weakness. The data is in no way representative of early modern text more generally, and, what’s more, the summaries were written in the 19th century and so will reflect what editors at the time thought was important. In these two ways, the corpus will reproduce a very particular wordview of a very specific group, at a very specific time. Because of this, can use the embeddings to get an idea of how certain words or ideas were semantically linked, <em>specifically in the corpus of calendar abstracts.</em> The data will not show us how early modern concepts were related, but it might show conceptual changes in words within the information apparatus of the state.</p>
<p>The following instructions are adapted from the <a href="http://text2vec.org/glove.html">project vignette</a> and <a href="https://m-clark.github.io/text-analysis-with-R/word-embeddings.html">this tutorial</a>. First, tokenise all the abstract text and remove very common words called stop words:</p>
<pre class="r"><code>library(text2vec)
library(tidytext)
library(textstem)</code></pre>
<pre><code>## Loading required package: koRpus.lang.en</code></pre>
<pre><code>## Loading required package: koRpus</code></pre>
<pre><code>## Loading required package: sylly</code></pre>
<pre><code>## For information on available language packages for &#39;koRpus&#39;, run
## 
##   available.koRpus.lang()
## 
## and see ?install.koRpus.lang()</code></pre>
<pre><code>## 
## Attaching package: &#39;koRpus&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:readr&#39;:
## 
##     tokenize</code></pre>
<pre class="r"><code>data(&quot;stop_words&quot;)</code></pre>
<p>Next, load and pre-process the abstract text:</p>
<pre class="r"><code>spo_raw = read_delim(&#39;/Users/Yann/Documents/MOST RECENT DATA/fromto_all_place_mapped_stuart_sorted&#39;, delim = &#39;\t&#39;, col_names = F )</code></pre>
<pre><code>## 
## ── Column specification ────────────────────────────────────────────────────────
## cols(
##   X1 = col_double(),
##   X2 = col_double(),
##   X3 = col_character(),
##   X4 = col_character(),
##   X5 = col_character(),
##   X6 = col_character(),
##   X7 = col_character(),
##   X8 = col_character()
## )</code></pre>
<pre class="r"><code>spo_mapped_people = read_delim(&#39;/Users/Yann/Downloads/people_docs_stuart_200421&#39;, delim = &#39;\t&#39;, col_names = F)</code></pre>
<pre><code>## 
## ── Column specification ────────────────────────────────────────────────────────
## cols(
##   X1 = col_double(),
##   X2 = col_character(),
##   X3 = col_character(),
##   X4 = col_character(),
##   X5 = col_character(),
##   X6 = col_character(),
##   X7 = col_logical()
## )</code></pre>
<pre class="r"><code>load(&#39;/Users/Yann/Documents/non-Github/spo_data/g&#39;)
g = g %&gt;% group_by(path) %&gt;% summarise(value = paste0(value, collapse = &quot;&lt;br&gt;&quot;))</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<pre class="r"><code>spo_raw = spo_raw %&gt;%
mutate(X7 = str_replace(X7, &quot;spo&quot;, &quot;SPO&quot;)) %&gt;%
separate(X7, into = c(&#39;Y1&#39;, &#39;Y2&#39;, &#39;Y3&#39;), sep = &#39;/&#39;) %&gt;%
mutate(fullpath = paste0(&quot;/Users/Yann/Documents/non-Github/spo_xml/&quot;, Y1, &#39;/XML/&#39;, Y2,&quot;/&quot;, Y3)) %&gt;% mutate(uniquecode = paste0(&quot;Z&quot;, 1:nrow(spo_raw), &quot;Z&quot;))

withtext = left_join(spo_raw, g, by = c(&#39;fullpath&#39; = &#39;path&#39;)) %&gt;%
left_join(spo_mapped_people %&gt;% dplyr::select(X1, from_name = X2), by = c(&#39;X1&#39; = &#39;X1&#39;))%&gt;%
left_join(spo_mapped_people %&gt;% dplyr::select(X1, to_name = X2), by = c(&#39;X2&#39; = &#39;X1&#39;)) </code></pre>
<p>Tokenize the text using the {Tidytext} function {unnest_tokens()}, remove stop words, lemmatize the text (reduce the words to their stem) using {textstem}, and remove numbers. This creates a new dataset, with one row per word, plus.</p>
<pre class="r"><code>words = withtext %&gt;% 
  ungroup()  %&gt;% 
  select(document = X5, value, date = X3) %&gt;%
  unnest_tokens(word, value) %&gt;% anti_join(stop_words)%&gt;% 
  mutate(word = lemmatize_words(word)) %&gt;% filter(!str_detect(word, &quot;[0-9]{1,}&quot;))</code></pre>
<pre><code>## Joining, by = &quot;word&quot;</code></pre>
<p>Create a ‘vocabulary’, which is just a list of each word found in the dataset and the times they occur, and ‘prune’ it to only words which occur at least five times.</p>
<pre class="r"><code>words_ls = list(words$word)

it = itoken(words_ls, progressbar = FALSE)

vocab = create_vocabulary(it)

vocab = prune_vocabulary(vocab, term_count_min = 5)</code></pre>
<p>With the vocabulary, construct a ‘term co-occurence matrix’: this is a matrix of rows and columns, counting all the times each word co-occurs with every other word, within a window which can be set with the argument <code>skip_grams_window =</code></p>
<pre class="r"><code>vectorizer = vocab_vectorizer(vocab)

# use window of 10 for context words
tcm = create_tcm(it, vectorizer, skip_grams_window = 10)</code></pre>
<p>Now use the GloVe algorithm to train the model and produce the vectors, with a set number of iterations: here we’ve used 20, which seems to give good results. It can be quite slow, but as it’s a relatively small dataset (in comparison to something like the entire English wikipedia), it shouldn’t take too long to run - a couple of minutes for 20 iterations.</p>
<pre class="r"><code>glove = GlobalVectors$new(rank = 100, x_max = 10)

wv_main = glove$fit_transform(tcm, n_iter = 20, convergence_tol = 0.00001)</code></pre>
<pre><code>## INFO  [17:31:09.701] epoch 1, loss 0.1509 
## INFO  [17:31:32.348] epoch 2, loss 0.0992 
## INFO  [17:31:54.901] epoch 3, loss 0.0878 
## INFO  [17:32:17.499] epoch 4, loss 0.0817 
## INFO  [17:32:40.086] epoch 5, loss 0.0778 
## INFO  [17:33:02.747] epoch 6, loss 0.0749 
## INFO  [17:33:25.273] epoch 7, loss 0.0727 
## INFO  [17:33:47.849] epoch 8, loss 0.0710 
## INFO  [17:34:10.401] epoch 9, loss 0.0696 
## INFO  [17:34:32.963] epoch 10, loss 0.0685 
## INFO  [17:34:55.542] epoch 11, loss 0.0675 
## INFO  [17:35:18.195] epoch 12, loss 0.0666 
## INFO  [17:35:40.787] epoch 13, loss 0.0659 
## INFO  [17:36:03.466] epoch 14, loss 0.0652 
## INFO  [17:36:26.088] epoch 15, loss 0.0647 
## INFO  [17:36:48.649] epoch 16, loss 0.0642 
## INFO  [17:37:11.207] epoch 17, loss 0.0637 
## INFO  [17:37:33.857] epoch 18, loss 0.0633 
## INFO  [17:37:56.621] epoch 19, loss 0.0629 
## INFO  [17:38:19.129] epoch 20, loss 0.0626</code></pre>
<p>GloVe results in two sets of word vectors. The authors of the GloVe package suggest that combining both results in higher-quality embeddings:</p>
<pre class="r"><code>wv_context = glove$components



# Either word-vectors matrices could work, but the developers of the technique
# suggest the sum/mean may work better
word_vectors = wv_main + t(wv_context)</code></pre>
</div>
<div id="results" class="section level4">
<h4>Results</h4>
<p>When it’s finished, write a small function which calculates and displays the closest words in distance to a given word. Instead of using the euclidean distance formula above, we calculate the <em>cosine similarity</em>, which measures the angular distance between the words (this is better because it <a href="https://cmry.github.io/notes/euclidean-v-cosine#:~:text=While%20cosine%20looks%20at%20the,though%20they%20were%20further%20away.">corrects for one word appearing many times and another appearing very infrequently</a>).</p>
<pre class="r"><code>ten_closest_words = function(word){

word_result = word_vectors[word, , drop = FALSE] 

cos_sim = sim2(x = word_vectors, y = word_result, method = &quot;cosine&quot;, norm = &quot;l2&quot;)


head(sort(cos_sim[,1], decreasing = TRUE), 20)

}</code></pre>
<p>The function takes a single word as an argument and returns the twenty closest word vectors, by cosine distance. What are the closest in useage to ‘king’?</p>
<pre class="r"><code>ten_closest_words(&#39;king&#39;)</code></pre>
<pre><code>##      king   majesty    king&#39;s     queen      late majesty&#39;s       seq    prince 
## 1.0000000 0.8124185 0.8115906 0.7544641 0.7394790 0.7276555 0.7186679 0.7103045 
##    please   england       cpg      duke        id        pg   promise     grant 
## 0.7099343 0.7034877 0.6939898 0.6939041 0.6891967 0.6883882 0.6882395 0.6853770 
##   declare      lord      time      pray 
## 0.6852612 0.6807144 0.6745944 0.6742028</code></pre>
<p>Unsurprisingly, a word that is often interchangeable with King, Majesty, is the closest, followed by ‘Queen’ - also obviously interchangeable with King, depending on the circumstances.</p>
<p>Word embeddings are often used to understand different and changing <a href="https://lab.kb.nl/about-us/blog/introduction-gender-bias-historical-newspapers">gender representations</a>. How are gendered words represented in the State Papers abstracts? First of all, wife:</p>
<pre class="r"><code>ten_closest_words(&#39;wife&#39;)</code></pre>
<pre><code>##      wife   husband     child    sister    mother      lady   brother  daughter 
## 1.0000000 0.8191674 0.7883127 0.7646102 0.7566901 0.7429047 0.7282066 0.7235836 
##       son     marry    father     widow    family     woman  writer&#39;s    friend 
## 0.6976267 0.6896181 0.6853372 0.6558982 0.6178040 0.6116087 0.6066610 0.6059600 
##      life   servant    wife&#39;s     uncle 
## 0.5971647 0.5971094 0.5952873 0.5922310</code></pre>
<p>Unsurprisingly wife is most similar to other words relating to family. What about husband?</p>
<pre class="r"><code>ten_closest_words(&#39;husband&#39;)</code></pre>
<pre><code>##   husband      wife     child     widow    mother    sister  daughter   brother 
## 1.0000000 0.8191674 0.7370158 0.6531169 0.6276656 0.6243364 0.6201605 0.6070677 
##    family     marry    father      lady       son   servant     woman       die 
## 0.6062919 0.5999262 0.5989705 0.5983755 0.5849611 0.5637674 0.5615799 0.5615049 
##  prisoner  petition      debt husband&#39;s 
## 0.5565017 0.5536114 0.5517856 0.5496583</code></pre>
<p>Husband is mostly similar but with some interesting different associations: ‘widow’, ‘die’, ‘petition’, ‘debt’, and ‘prisoner’, reflecting the fact that there is a large group of petitions in the State Papers written by women looking for pardons or clemency for their husbands, particularly following the Monmouth Rebellion in 1683.</p>
<p>Looking at the closest words to place names gives some interesting associations. Amsterdam is associated with terms related to shipping and trade:</p>
<pre class="r"><code>ten_closest_words(&#39;amsterdam&#39;)</code></pre>
<pre><code>## amsterdam rotterdam      lade  bordeaux   hamburg   holland    richly     dutch 
## 1.0000000 0.7252002 0.6393961 0.5937090 0.5631972 0.5539730 0.5471240 0.5428466 
##  merchant     texel     prize    vessel  dutchman    arrive   zealand     flush 
## 0.5420471 0.5295916 0.5276372 0.5258728 0.5229681 0.5200589 0.5122757 0.5090996 
##    london    french  rochelle    nantes 
## 0.5088864 0.5063027 0.5030953 0.5019438</code></pre>
<p>Whereas Rome is very much associated with religion and ecclesiastical politics:</p>
<pre class="r"><code>ten_closest_words(&#39;rome&#39;)</code></pre>
<pre><code>##       rome       pope     jesuit     priest      friar     nuncio   cardinal 
##  1.0000000  0.6357303  0.6291777  0.5639153  0.5457535  0.5339667  0.5221153 
##      spain     naples   florence   catholic     venice      paris     pope&#39;s 
##  0.5080164  0.5063024  0.5036499  0.4967918  0.4937650  0.4878270  0.4822044 
##   religion ambassador      italy     tyrone    shortly     depart 
##  0.4794766  0.4543575  0.4483097  0.4387691  0.4326920  0.4322462</code></pre>
</div>
<div id="more-complex-vector-tasks" class="section level4">
<h4>More Complex Vector Tasks</h4>
<p>As well as finding the most similar words, we can also perform arithmetic on the vectors. What is the closest word to book and news:</p>
<pre class="r"><code>sum = word_vectors[&quot;husband&quot;, , drop = F] -
 word_vectors[&quot;petition&quot;, , drop = F]

cos_sim_test = sim2(x = word_vectors, y = sum, method = &quot;cosine&quot;, norm = &quot;l2&quot;)

head(sort(cos_sim_test[,1], decreasing = T), 20)</code></pre>
<pre><code>##  coarseness  relievable       broth         owl rushworth&#39;s    cloathes 
##   0.4678656   0.4617825   0.4562565   0.4521938   0.4521481   0.4512532 
##         gad      slatch    fosterer    hurley&#39;s   o&#39;neile&#39;s       sluis 
##   0.4503194   0.4450165   0.4438963   0.4266353   0.4259293   0.4214021 
##    plowland   innsbruck   uncharged  pardonable    milander    vanquish 
##   0.4212738   0.4172199   0.4164849   0.4155880   0.4155654   0.4153549 
##     caliver everlasting 
##   0.4153530   0.4141557</code></pre>
<p>It is also a way of finding analogies: so, for example, Paris - France + Germany should equal to ‘Berlin’, because Berlin is like the Paris of France. Is that what we get?</p>
<pre class="r"><code>test = word_vectors[&quot;paris&quot;, , drop = F] -
  word_vectors[&quot;france&quot;, , drop = F] +
  word_vectors[&quot;germany&quot;, , drop = F]
  
#+
 # shakes_word_vectors[&quot;letter&quot;, , drop = F]

cos_sim_test = sim2(x = word_vectors, y = test, method = &quot;cosine&quot;, norm = &quot;l2&quot;)

head(sort(cos_sim_test[,1], decreasing = T), 10)</code></pre>
<pre><code>##     paris   germany       n.s  brussels frankfort     stilo tuesday&#39;s        ps 
## 0.6346836 0.6185004 0.4993398 0.4934119 0.4434699 0.4323685 0.4251119 0.4249966 
##    veteri   edmonds 
## 0.4216843 0.4046615</code></pre>
<p>After Germany and Paris, the most similar to Paris - France + Germany is Brussels: not the correct answer, but a close enough guess!</p>
<p>We can try other analogies: pen - letter + book should in theory give some word related to printing and book production such as print, or press, or maybe type (Think pen is to letter as X is to book).</p>
<pre class="r"><code>test = word_vectors[&quot;pen&quot;, , drop = F] -
  word_vectors[&quot;letter&quot;, , drop = F] +
    word_vectors[&quot;book&quot;, , drop = F]
  
cos_sim_test = sim2(x = word_vectors, y = test, method = &quot;cosine&quot;, norm = &quot;l2&quot;)

head(sort(cos_sim_test[,1], decreasing = T), 20)</code></pre>
<pre><code>##           pen          book storekeeper&#39;s     bywater&#39;s        stitch 
##     0.5621649     0.5316695     0.5074405     0.4820687     0.4793163 
##         bible      pamphlet           ink     catalogue    manuscript 
##     0.4668026     0.4600276     0.4530105     0.4523773     0.4491164 
##    unlicensed       library     catechize        shalbe        closet 
##     0.4451364     0.4402602     0.4337235     0.4242770     0.4210233 
##        weapon     testament       history        broach        symbol 
##     0.4191993     0.4178388     0.4165598     0.4140450     0.4105902</code></pre>
<p>Not bad - printer is in the top 20! The closest is ink, plus some other book-production-related words like stitch, ream, and pamphlet. Though some of these words can also be associated with manuscript production, we <em>could</em> be generous and say that they are sort of to a book as a pen is to a letter!</p>
</div>
<div id="change-in-semantic-relations-over-time" class="section level4">
<h4>Change in Semantic Relations Over Time</h4>
<p>We can also look for change in semantic meaning over time. First, divide the text into four separate sections, one for each reign:</p>
<pre class="r"><code>library(lubridate)</code></pre>
<pre><code>## 
## Attaching package: &#39;lubridate&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:base&#39;:
## 
##     date, intersect, setdiff, union</code></pre>
<pre class="r"><code>james_i = withtext %&gt;% 
  mutate(year = year(ymd(X4))) %&gt;% 
  filter(year %in% 1603:1624) %&gt;% 
  ungroup()  %&gt;% 
  select(document = X5, value, date = X3) %&gt;%
  unnest_tokens(word, value) %&gt;% 
  anti_join(stop_words) %&gt;% 
  mutate(word = lemmatize_words(word)) %&gt;% filter(!str_detect(word, &quot;[0-9]{1,}&quot;))</code></pre>
<pre><code>## Warning: Problem with `mutate()` input `year`.
## ℹ  24 failed to parse.
## ℹ Input `year` is `year(ymd(X4))`.</code></pre>
<pre><code>## Warning: 24 failed to parse.</code></pre>
<pre><code>## Joining, by = &quot;word&quot;</code></pre>
<pre class="r"><code>charles_i = withtext %&gt;% 
  mutate(year = year(ymd(X4))) %&gt;% 
  filter(year %in% 1625:1648) %&gt;% 
  ungroup()  %&gt;% 
  select(document = X5, value, date = X3) %&gt;%
  unnest_tokens(word, value) %&gt;% anti_join(stop_words)%&gt;% 
  mutate(word = lemmatize_words(word)) %&gt;% filter(!str_detect(word, &quot;[0-9]{1,}&quot;))</code></pre>
<pre><code>## Warning: Problem with `mutate()` input `year`.
## ℹ  24 failed to parse.
## ℹ Input `year` is `year(ymd(X4))`.

## Warning:  24 failed to parse.</code></pre>
<pre><code>## Joining, by = &quot;word&quot;</code></pre>
<pre class="r"><code>commonwealth = withtext %&gt;% 
  mutate(year = year(ymd(X4))) %&gt;% 
  filter(year %in% 1649:1659) %&gt;% 
  ungroup()  %&gt;% 
  select(document = X5, value, date = X3) %&gt;%
  unnest_tokens(word, value) %&gt;% anti_join(stop_words)%&gt;% 
  mutate(word = lemmatize_words(word)) %&gt;% filter(!str_detect(word, &quot;[0-9]{1,}&quot;))</code></pre>
<pre><code>## Warning: Problem with `mutate()` input `year`.
## ℹ  24 failed to parse.
## ℹ Input `year` is `year(ymd(X4))`.

## Warning:  24 failed to parse.</code></pre>
<pre><code>## Joining, by = &quot;word&quot;</code></pre>
<pre class="r"><code>charles_ii = withtext %&gt;% 
  mutate(year = year(ymd(X4))) %&gt;% 
  filter(year %in% 1660:1684) %&gt;% 
  ungroup()  %&gt;% 
  select(document = X5, value, date = X3) %&gt;%
  unnest_tokens(word, value) %&gt;% anti_join(stop_words)%&gt;% 
  mutate(word = lemmatize_words(word)) %&gt;% filter(!str_detect(word, &quot;[0-9]{1,}&quot;))</code></pre>
<pre><code>## Warning: Problem with `mutate()` input `year`.
## ℹ  24 failed to parse.
## ℹ Input `year` is `year(ymd(X4))`.

## Warning:  24 failed to parse.</code></pre>
<pre><code>## Joining, by = &quot;word&quot;</code></pre>
<pre class="r"><code>james_ii_w_m_ann = withtext %&gt;% 
  mutate(year = year(ymd(X4))) %&gt;% 
  filter(year %in% 1685:1714) %&gt;% 
  ungroup()  %&gt;% 
  select(document = X5, value, date = X3) %&gt;%
  unnest_tokens(word, value) %&gt;% anti_join(stop_words) %&gt;% 
  mutate(word = lemmatize_words(word)) %&gt;% filter(!str_detect(word, &quot;[0-9]{1,}&quot;))</code></pre>
<pre><code>## Warning: Problem with `mutate()` input `year`.
## ℹ  24 failed to parse.
## ℹ Input `year` is `year(ymd(X4))`.

## Warning:  24 failed to parse.</code></pre>
<pre><code>## Joining, by = &quot;word&quot;</code></pre>
<p>Now run the same scripts as above, on each of these sections:</p>
<pre class="r"><code>james_i_words_ls = list(james_i$word)
it = itoken(james_i_words_ls, progressbar = FALSE)
james_i_vocab = create_vocabulary(it)
james_i_vocab = prune_vocabulary(james_i_vocab, term_count_min = 5)

vectorizer = vocab_vectorizer(james_i_vocab)

# use window of 10 for context words
james_i_tcm = create_tcm(it, vectorizer, skip_grams_window = 10)

james_i_glove = GlobalVectors$new(rank = 100, x_max = 10)

james_i_wv_main = james_i_glove$fit_transform(james_i_tcm, n_iter = 20, convergence_tol = 0.00001)</code></pre>
<pre><code>## INFO  [17:16:31.689] epoch 1, loss 0.1524 
## INFO  [17:16:37.300] epoch 2, loss 0.0920 
## INFO  [17:16:42.907] epoch 3, loss 0.0784 
## INFO  [17:16:48.506] epoch 4, loss 0.0712 
## INFO  [17:16:54.110] epoch 5, loss 0.0665 
## INFO  [17:16:59.755] epoch 6, loss 0.0630 
## INFO  [17:17:05.392] epoch 7, loss 0.0604 
## INFO  [17:17:11.069] epoch 8, loss 0.0583 
## INFO  [17:17:16.950] epoch 9, loss 0.0566 
## INFO  [17:17:22.686] epoch 10, loss 0.0551 
## INFO  [17:17:28.362] epoch 11, loss 0.0539 
## INFO  [17:17:34.040] epoch 12, loss 0.0529 
## INFO  [17:17:39.680] epoch 13, loss 0.0519 
## INFO  [17:17:45.334] epoch 14, loss 0.0511 
## INFO  [17:17:51.052] epoch 15, loss 0.0504 
## INFO  [17:17:56.712] epoch 16, loss 0.0498 
## INFO  [17:18:02.732] epoch 17, loss 0.0492 
## INFO  [17:18:08.533] epoch 18, loss 0.0487 
## INFO  [17:18:14.293] epoch 19, loss 0.0482 
## INFO  [17:18:19.948] epoch 20, loss 0.0478</code></pre>
<pre class="r"><code>james_i_wv_context = james_i_glove$components

james_i_word_vectors = james_i_wv_main + t(james_i_wv_context)</code></pre>
<pre class="r"><code>charles_i_words_ls = list(charles_i$word)
it = itoken(charles_i_words_ls, progressbar = FALSE)
charles_i_vocab = create_vocabulary(it)
charles_i_vocab = prune_vocabulary(charles_i_vocab, term_count_min = 5)

vectorizer = vocab_vectorizer(charles_i_vocab)

# use window of 10 for context words
charles_i_tcm = create_tcm(it, vectorizer, skip_grams_window = 10)

charles_i_glove = GlobalVectors$new(rank = 100, x_max = 10)

charles_i_wv_main = charles_i_glove$fit_transform(charles_i_tcm, n_iter = 20, convergence_tol = 0.00001)</code></pre>
<pre><code>## INFO  [17:18:43.547] epoch 1, loss 0.1507 
## INFO  [17:18:50.483] epoch 2, loss 0.0917 
## INFO  [17:18:57.431] epoch 3, loss 0.0789 
## INFO  [17:19:04.382] epoch 4, loss 0.0721 
## INFO  [17:19:11.262] epoch 5, loss 0.0676 
## INFO  [17:19:18.212] epoch 6, loss 0.0644 
## INFO  [17:19:25.123] epoch 7, loss 0.0619 
## INFO  [17:19:31.998] epoch 8, loss 0.0599 
## INFO  [17:19:38.897] epoch 9, loss 0.0582 
## INFO  [17:19:45.768] epoch 10, loss 0.0568 
## INFO  [17:19:52.638] epoch 11, loss 0.0557 
## INFO  [17:19:59.501] epoch 12, loss 0.0547 
## INFO  [17:20:06.383] epoch 13, loss 0.0538 
## INFO  [17:20:13.262] epoch 14, loss 0.0530 
## INFO  [17:20:20.135] epoch 15, loss 0.0523 
## INFO  [17:20:26.979] epoch 16, loss 0.0517 
## INFO  [17:20:33.833] epoch 17, loss 0.0512 
## INFO  [17:20:40.679] epoch 18, loss 0.0507 
## INFO  [17:20:47.559] epoch 19, loss 0.0502 
## INFO  [17:20:54.457] epoch 20, loss 0.0498</code></pre>
<pre class="r"><code>charles_i_wv_context = charles_i_glove$components

charles_i_word_vectors = charles_i_wv_main + t(charles_i_wv_context)</code></pre>
<pre class="r"><code>commonwealth_words_ls = list(commonwealth$word)
it = itoken(commonwealth_words_ls, progressbar = FALSE)
commonwealth_vocab = create_vocabulary(it)
commonwealth_vocab = prune_vocabulary(commonwealth_vocab, term_count_min = 5)

vectorizer = vocab_vectorizer(commonwealth_vocab)

# use window of 10 for context words
commonwealth_tcm = create_tcm(it, vectorizer, skip_grams_window = 10)

commonwealth_glove = GlobalVectors$new(rank = 100, x_max = 10)

commonwealth_wv_main = commonwealth_glove$fit_transform(commonwealth_tcm, n_iter = 20, convergence_tol = 0.00001)</code></pre>
<pre><code>## INFO  [17:21:11.185] epoch 1, loss 0.1698 
## INFO  [17:21:14.208] epoch 2, loss 0.0949 
## INFO  [17:21:17.206] epoch 3, loss 0.0791 
## INFO  [17:21:20.205] epoch 4, loss 0.0709 
## INFO  [17:21:23.219] epoch 5, loss 0.0656 
## INFO  [17:21:26.209] epoch 6, loss 0.0618 
## INFO  [17:21:29.212] epoch 7, loss 0.0588 
## INFO  [17:21:32.203] epoch 8, loss 0.0564 
## INFO  [17:21:35.196] epoch 9, loss 0.0544 
## INFO  [17:21:38.176] epoch 10, loss 0.0528 
## INFO  [17:21:41.161] epoch 11, loss 0.0514 
## INFO  [17:21:44.152] epoch 12, loss 0.0502 
## INFO  [17:21:47.147] epoch 13, loss 0.0492 
## INFO  [17:21:50.146] epoch 14, loss 0.0483 
## INFO  [17:21:53.154] epoch 15, loss 0.0474 
## INFO  [17:21:56.164] epoch 16, loss 0.0467 
## INFO  [17:21:59.176] epoch 17, loss 0.0460 
## INFO  [17:22:02.194] epoch 18, loss 0.0455 
## INFO  [17:22:05.229] epoch 19, loss 0.0449 
## INFO  [17:22:08.244] epoch 20, loss 0.0444</code></pre>
<pre class="r"><code>commonwealth_wv_context = commonwealth_glove$components

# dim(shakes_wv_context)

# Either word-vectors matrices could work, but the developers of the technique
# suggest the sum/mean may work better
commonwealth_word_vectors = commonwealth_wv_main + t(commonwealth_wv_context)</code></pre>
<pre class="r"><code>charles_ii_words_ls = list(charles_ii$word)
it = itoken(charles_ii_words_ls, progressbar = FALSE)
charles_ii_vocab = create_vocabulary(it)
charles_ii_vocab = prune_vocabulary(charles_ii_vocab, term_count_min = 5)

vectorizer = vocab_vectorizer(charles_ii_vocab)

# use window of 10 for context words
charles_ii_tcm = create_tcm(it, vectorizer, skip_grams_window = 10)

charles_ii_glove = GlobalVectors$new(rank = 100, x_max = 10)

charles_ii_wv_main = charles_ii_glove$fit_transform(charles_ii_tcm, n_iter = 20, convergence_tol = 0.00001)</code></pre>
<pre><code>## INFO  [17:22:37.388] epoch 1, loss 0.1471 
## INFO  [17:22:47.902] epoch 2, loss 0.0907 
## INFO  [17:22:58.372] epoch 3, loss 0.0787 
## INFO  [17:23:08.867] epoch 4, loss 0.0725 
## INFO  [17:23:19.411] epoch 5, loss 0.0685 
## INFO  [17:23:29.958] epoch 6, loss 0.0655 
## INFO  [17:23:40.446] epoch 7, loss 0.0633 
## INFO  [17:23:50.911] epoch 8, loss 0.0615 
## INFO  [17:24:01.401] epoch 9, loss 0.0601 
## INFO  [17:24:11.862] epoch 10, loss 0.0589 
## INFO  [17:24:22.352] epoch 11, loss 0.0579 
## INFO  [17:24:33.497] epoch 12, loss 0.0570 
## INFO  [17:24:44.056] epoch 13, loss 0.0562 
## INFO  [17:24:54.523] epoch 14, loss 0.0555 
## INFO  [17:25:05.205] epoch 15, loss 0.0549 
## INFO  [17:25:15.767] epoch 16, loss 0.0544 
## INFO  [17:25:26.533] epoch 17, loss 0.0539 
## INFO  [17:25:37.089] epoch 18, loss 0.0535 
## INFO  [17:25:47.544] epoch 19, loss 0.0531 
## INFO  [17:25:57.995] epoch 20, loss 0.0527</code></pre>
<pre class="r"><code>charles_ii_wv_context = charles_ii_glove$components

# dim(shakes_wv_context)

# Either word-vectors matrices could work, but the developers of the technique
# suggest the sum/mean may work better
charles_ii_word_vectors = charles_ii_wv_main + t(charles_ii_wv_context)</code></pre>
<pre class="r"><code>james_ii_w_m_ann_words_ls = list(james_ii_w_m_ann$word)
it = itoken(james_ii_w_m_ann_words_ls, progressbar = FALSE)
james_ii_w_m_ann_vocab = create_vocabulary(it)
james_ii_w_m_ann_vocab = prune_vocabulary(james_ii_w_m_ann_vocab, term_count_min = 5)

vectorizer = vocab_vectorizer(james_ii_w_m_ann_vocab)

# use window of 10 for context words
james_ii_w_m_ann_tcm = create_tcm(it, vectorizer, skip_grams_window = 10)

james_ii_w_m_ann_glove = GlobalVectors$new(rank = 100, x_max = 10)

james_ii_w_m_ann_wv_main = james_ii_w_m_ann_glove$fit_transform(james_ii_w_m_ann_tcm, n_iter = 20, convergence_tol = 0.00001)</code></pre>
<pre><code>## INFO  [17:26:22.827] epoch 1, loss 0.1597 
## INFO  [17:26:27.423] epoch 2, loss 0.0926 
## INFO  [17:26:32.043] epoch 3, loss 0.0788 
## INFO  [17:26:36.634] epoch 4, loss 0.0714 
## INFO  [17:26:41.208] epoch 5, loss 0.0665 
## INFO  [17:26:45.857] epoch 6, loss 0.0629 
## INFO  [17:26:50.441] epoch 7, loss 0.0601 
## INFO  [17:26:55.035] epoch 8, loss 0.0579 
## INFO  [17:26:59.668] epoch 9, loss 0.0561 
## INFO  [17:27:04.263] epoch 10, loss 0.0546 
## INFO  [17:27:08.907] epoch 11, loss 0.0533 
## INFO  [17:27:13.487] epoch 12, loss 0.0522 
## INFO  [17:27:18.088] epoch 13, loss 0.0512 
## INFO  [17:27:22.699] epoch 14, loss 0.0504 
## INFO  [17:27:27.323] epoch 15, loss 0.0496 
## INFO  [17:27:31.903] epoch 16, loss 0.0490 
## INFO  [17:27:36.494] epoch 17, loss 0.0483 
## INFO  [17:27:41.151] epoch 18, loss 0.0478 
## INFO  [17:27:45.735] epoch 19, loss 0.0473 
## INFO  [17:27:50.313] epoch 20, loss 0.0468</code></pre>
<pre class="r"><code>james_ii_w_m_ann_wv_context = james_ii_w_m_ann_glove$components

# dim(shakes_wv_context)

# Either word-vectors matrices could work, but the developers of the technique
# suggest the sum/mean may work better
james_ii_w_m_ann_word_vectors = james_ii_w_m_ann_wv_main + t(james_ii_w_m_ann_wv_context)</code></pre>
<p>Write a function as above, this time with two arguments, so we can specify both the word and the relevant reign:</p>
<pre class="r"><code>top_ten_function = function(word, period){
  
  
  if(period == &#39;james_i&#39;){
    
  vectors = james_i_word_vectors[word, , drop = FALSE] 
  cos_sim = sim2(x = james_i_word_vectors, y = vectors, method = &quot;cosine&quot;, norm = &quot;l2&quot;)


}
  else if(period == &#39;charles_i&#39;){  vectors = charles_i_word_vectors[word, , drop = FALSE] 
  cos_sim = sim2(x = charles_i_word_vectors, y = vectors, method = &quot;cosine&quot;, norm = &quot;l2&quot;)
  
  } 
  else if(period == &#39;commonwealth&#39;)  { 
    
    vectors = commonwealth_word_vectors[word, , drop = FALSE] 
  cos_sim = sim2(x = commonwealth_word_vectors, y = vectors, method = &quot;cosine&quot;, norm = &quot;l2&quot;)
  
  }
  
  else if(period == &#39;charles_ii&#39;){
    
    vectors = charles_ii_word_vectors[word, , drop = FALSE] 
  cos_sim = sim2(x = charles_ii_word_vectors, y = vectors, method = &quot;cosine&quot;, norm = &quot;l2&quot;)
  
  }
  
  else {
    
  vectors = james_ii_w_m_ann_word_vectors[word, , drop = FALSE] 
  cos_sim = sim2(x = james_ii_w_m_ann_word_vectors, y = vectors, method = &quot;cosine&quot;, norm = &quot;l2&quot;)
  }
  
head(sort(cos_sim[,1], decreasing = TRUE), 20)


}</code></pre>
<p>Write a second function, which takes a word and returns the ten closest words for each reign:</p>
<pre class="r"><code>first_in_each= function(word) {
  
  rbind(top_ten_function(word, &#39;james_i&#39;) %&gt;% tibble::enframe() %&gt;% arrange(desc(value)) %&gt;% slice(2:11) %&gt;% mutate(reign =&#39;james_i&#39; ),
     top_ten_function(word, &#39;charles_i&#39;) %&gt;% tibble::enframe() %&gt;% arrange(desc(value)) %&gt;% slice(2:11) %&gt;% mutate(reign =&#39;charles_i&#39; ),
     top_ten_function(word, &#39;commonwealth&#39;) %&gt;% tibble::enframe() %&gt;% arrange(desc(value)) %&gt;% slice(2:11) %&gt;% mutate(reign =&#39;commonwealth&#39; ),
     top_ten_function(word, &#39;charles_ii&#39;) %&gt;% tibble::enframe() %&gt;% arrange(desc(value)) %&gt;% slice(2:11) %&gt;% mutate(reign =&#39;charles_ii&#39; ),
     top_ten_function(word, &#39;james_ii_w_m_ann&#39;) %&gt;% tibble::enframe() %&gt;% arrange(desc(value)) %&gt;% slice(2:11) %&gt;% mutate(reign =&#39;james_ii_w_m_ann&#39; ))%&gt;% 
  group_by(reign) %&gt;% 
  mutate(rank = rank(value)) %&gt;% 
  ggplot() + 
  geom_text(aes(x = factor(reign, levels = c(&#39;james_i&#39;, &#39;charles_i&#39;, &#39;commonwealth&#39;, &#39;charles_ii&#39;, &#39;james_ii&#39;, &#39;james_ii_w_m_ann&#39;)), y = rank, label = name, color = name)) + theme_void() +
  theme(legend.position = &#39;none&#39;, 
        axis.text.x = element_text(face = &#39;bold&#39;), 
        ) 
  
  }</code></pre>
<p>This can show us the changing associations of particular words over time. Take ‘match’:</p>
<pre class="r"><code>first_in_each(&#39;match&#39;) </code></pre>
<p><img src="https://networkingarchives.github.io/blog/2021/04/14/representing-calendars-of-state-papers-with-word-vectors/index_files/figure-html/unnamed-chunk-36-1.png" width="672" /></p>
<p>In the reign of James I, ‘match’ is semantically linked to words relating to the <a href="https://en.wikipedia.org/wiki/Spanish_match">Spanish Match</a>: a proposed match between Charles I and the Infanta Maria Anna of Spain. During Charles I’s reign and afterwards, the meaning changes completely - now the closest words are all military. In the final section of the data, the semantic link returns again to mostly words about marriage - this time it’s not so obvious why the words are associated, but it’s probably relating to the marriage of Philippe II, Duke of Orléans to Françoise Marie de Bourbon, in 1692 - Philippe II was regent of France until 1723.</p>
</div>
<div id="conclusions" class="section level4">
<h4>Conclusions</h4>
<p>The word embeddings trained on the text of the Calendars have shown how certain words related to particular topics. We’ve seen that it often produces expected results (such as <em>King</em> being closest to <em>Majesty</em>), even in complex tasks: with the analogy pen is to letter as X is to book, X is replaced by <em>ink</em>, <em>printer</em>, <em>pamphlet</em>, and some other relevant book-production words. Certain words can be seen to change over time: <em>match</em> is a good example, which is linked to marriage at some times, and weaponry at others, depending on the time period. Many of these word associations reflect biases in the data, but in certain circumstances this can be a strength rather than a weakness. The danger is not investigating the biases, but rather when we are reductive and try to claim that the word associations seen here are in any way representative of how society at large thought about these concepts more generally. On their own terms, the embeddings can be a powerful historical tool to understand the linked meanings within a discrete set of sources.</p>
</div>
<div id="further-reading" class="section level4">
<h4>Further Reading</h4>
<p><a href="https://www.wwp.northeastern.edu/outreach/seminars/wem_2019-07/presentations/word_vectors/word_vectors_intro_lecture.xhtml">Good basic introduction to word vectors</a></p>
<p><a href="https://dhh.uni.lu/2018/12/11/word-embeddings-in-humanities/">Word Embeddings in Humanities</a></p>
<p><a href="https://lab.kb.nl/about-us/blog/introduction-gender-bias-historical-newspapers">Gender bias in historical newspapers</a></p>
<p><a href="https://nlp.stanford.edu/projects/histwords/">HistWords:Word Embeddings for Historical Text</a></p>
</div>
</div>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/blog/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/blog/images/hugo-logo.png" alt="Img link to Hugo website" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/blog/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
  </body>
</html>

